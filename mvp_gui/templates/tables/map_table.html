<div id="map" class="map"></div>

<style>
    .cWpt-custom-marker {
    display: flex;
    flex-direction: column;
    align-items: center;
    }

    .cWpt-triangle {
        width: 0;
        height: 0;
        border-left: 5px solid transparent;
        border-right: 5px solid transparent;
        border-top: 10px solid red; /* Default color, can be overridden */
    }

    .cWpt-id-display {
        margin-top: 5px;
        font-size: 12px;
        color: yellow;
        background: transparent;
        padding: 2px 5px;
    }  

    .wpt-custom-marker {
        display: flex;
        flex-direction: column;
        align-items: center;
    }

    .wpt-diamond {
        width: 20px;
        height: 20px;
        background-color: red; /* Default color, can be overridden */
        transform: rotate(45deg);
        position: relative;
    }

    .wpt-id-display {
        margin-top: 5px;
        font-size: 15px;
        color: black;
        background: transparent; /* Make the background transparent */
        padding: 2px 5px;
    }

    .marker-container {
        display: flex;
        justify-content: center;
        align-items: center;
    }

    .arrow-marker {
        width: 40px; /* Adjust size as needed */
        height: 40px; /* Adjust size as needed */
        background: url('{{ url_for('static', filename='icons/white_arrow.png') }}') no-repeat center center;
        background-size: contain;
        transform-origin: center;
    }

</style>

<!-- Include the script.js file -->
<script>
    const updateInterval = 1000; // Update interval in milliseconds
    let isDragging = false; // Dragging flag
    let intervalId_map = null;

    // Simulating `jsonData` and `vehicleData` server-provided data
    const jsonData = {{ items_jsn | safe }};
    const cWptData ={{citems_jsn | safe}};
    const vehicleData = {{ vehicle_jsn | safe }};

    const coordinates = document.getElementById('coordinates');

    // online////////////////////////////////////////
    // const map = new maplibregl.Map({
    //     container: 'map',
    //     zoom: 12,
    //     center: [vehicleData.lon, vehicleData.lat], //long lat
    //     style:
    //         'https://api.maptiler.com/maps/hybrid/style.json?key=XiFHd4BzZGlB2Dsix5mK'
    // });
    //////////////////////////////////////////////////////

    // offline////////////////////////////////////////////
    const serverIp = "{{ host_ip }}";  // Injected server IP
    const map = new maplibregl.Map({
        container: 'map',
        zoom: 15,
        center: [vehicleData.lon, vehicleData.lat], // long lat
        style: {
            "version": 8,
            "sources": {
                "local-tiles": {
                    "type": "raster",
                    "tiles": [
                        `http://${serverIp}:5000/tiles/{z}/{x}/{y}.png`
                    ],
                    "tileSize": 256
                }
            },
            "layers": [
                {
                    "id": "local-tiles-layer",
                    "type": "raster",
                    "source": "local-tiles"
                }
            ]
        }
    });
    //////////////////////////////////////////////////////
    map.setCenter([vehicleData.lon, vehicleData.lat]);
    map.addControl(new maplibregl.NavigationControl());
    map.addControl(new maplibregl.ScaleControl({
        maxWidth: 80,
        unit: 'metric' // 'metric' or 'nautical'
    }));

    // Prepare GeoJSON data for the route
    let coordinatesData = jsonData.map(entry => ({
        latitude: entry.lat,
        longitude: entry.lon
    }));

    // Prepare GeoJSON data for the route
    let coordinatesData_cWpt = cWptData.map(entry => ({
        latitude: entry.lat,
        longitude: entry.lon
    }));

    // Create a custom HTML element for the arrow marker
    const markerContainer = document.createElement('div');
    markerContainer.className = 'marker-container';

    const arrowElement = document.createElement('div');
    arrowElement.className = 'arrow-marker';

    markerContainer.appendChild(arrowElement);

    vehicleMarker = new maplibregl.Marker({ element: markerContainer, draggable: false })
        .setLngLat([vehicleData.lon, vehicleData.lat])
        .addTo(map);

    let markers = [];
    let current_wpt_markers = [];
    
    function updateRoute() {
        map.getSource('route1').setData({
            type: 'FeatureCollection',
            features: [
                {
                    type: 'Feature',
                    geometry: {
                        type: 'LineString',
                        coordinates: coordinatesData.map(coord => [coord.longitude, coord.latitude])
                    }
                }
            ]
        });
        map.getSource('route2').setData({
            type: 'FeatureCollection',
            features: [
                {
                    type: 'Feature',
                    geometry: {
                        type: 'LineString',
                        coordinates: coordinatesData_cWpt.map(coord => [coord.longitude, coord.latitude])
                    }
                }
            ]
        });
    }

    function onDragStart() {
        isDragging = true; // Set dragging flag
    }

    function onDragEnd(marker, item) {
        return function () {
            const coordinates = marker.getLngLat();
            fetch('/waypoint_drag', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    id: item.id,
                    lng: coordinates.lng,
                    lat: coordinates.lat
                })
            }).catch(error => console.error('Error:', error));

            // Update coordinates data
            const index = coordinatesData.findIndex(coord => coord.id === item.id);
            if (index !== -1) {
                coordinatesData[index] = { id: item.id, longitude: coordinates.lng, latitude: coordinates.lat };
            }

            // Update the GeoJSON data for the line
            updateRoute();
            isDragging = false; // Reset dragging flag
        };
    }

    function createMarker(item, color) {
        // Create a custom HTML element for the marker
        const markerElement = document.createElement('div');
        markerElement.className = 'wpt-custom-marker';

        // Create the diamond element
        const diamond = document.createElement('div');
        diamond.className = 'wpt-diamond';
        diamond.style.backgroundColor = color;

        // Create the ID display element
        const idDisplay = document.createElement('div');
        idDisplay.className = 'wpt-id-display';
        idDisplay.style.color = color;
        idDisplay.innerText = item.id;

        // Append the diamond and ID display to the marker element
        markerElement.appendChild(diamond);
        markerElement.appendChild(idDisplay);

        // Create the marker using the custom HTML element
        const marker = new maplibregl.Marker({ element: markerElement, draggable: true })
            .setLngLat([item.lon, item.lat])
            .addTo(map);

        // Store the marker ID in the marker's element dataset
        marker.getElement().dataset.id = item.id;

        // Attach drag event listeners
        marker.on('dragstart', onDragStart);
        marker.on('dragend', onDragEnd(marker, item));

        markers.push(marker);
    }

    function createMarker_nondraggable(item, color) {
        // Create a custom HTML element for the marker
        const markerElement = document.createElement('div');
        markerElement.className = 'cWpt-custom-marker';

        // Create the triangle element
        const triangle = document.createElement('div');
        triangle.className = 'cWpt-triangle';
        triangle.style.borderTopColor = color;

        // Create the ID display element
        const idDisplay = document.createElement('div');
        idDisplay.className = 'cWpt-id-display';
        idDisplay.innerText = item.id + 1;

        // Append the triangle and ID display to the marker element
        // markerElement.appendChild(triangle);
        markerElement.appendChild(idDisplay);

        // Create the marker using the custom HTML element
        const marker = new maplibregl.Marker({ element: markerElement, draggable: false })
            .setLngLat([item.lon, item.lat])
            .addTo(map);
        
        // Store the marker ID in the marker's element dataset
        marker.getElement().dataset.id = item.id;
                
        current_wpt_markers.push(marker);
    }

    function updateMarkers() {
        if (isDragging) {
            return; // Skip updating markers if a marker is being dragged
        }

        fetch('/latest_data')
            .then(response => response.json())
            .then(data => {
                const newJsonData = data.waypoints;  
                const newcWptData = data.current_waypoints;     
                const newVehicleData = data.vehicle;
                // Create or update the vehicle marker
                if (vehicleMarker) {
                    vehicleMarker.setLngLat([newVehicleData.lon, newVehicleData.lat]);
                    const arrowElement = vehicleMarker.getElement().querySelector('.arrow-marker');
                    arrowElement.style.transform = `rotate(${90 - newVehicleData.yaw}deg)`;                    
                } 

                current_wpt_markers.forEach(marker => marker.remove());
                current_wpt_markers = [];
                newcWptData.forEach((item, index) => {
                    createMarker_nondraggable({ id: item.id, lon: item.lon, lat: item.lat }, "#FFFF00");
                });

                // Update or create markers
                newJsonData.forEach((item, index) => {
                    const existingMarker = markers.find(marker => marker.getElement().dataset.id == item.id);
                    if (existingMarker) {
                        existingMarker.setLngLat([item.lon, item.lat]);
                    } else {
                        let color = item.id === 1 ? "#e50112" : "#808080";
                        if (index === newJsonData.length - 1) {
                            color = "#00FF00";
                        }
                        createMarker({ id: item.id, lon: item.lon, lat: item.lat }, color);
                    }
                });

                

                // Remove markers that are no longer in the new data
                markers = markers.filter(marker => {
                    const markerId = marker.getElement().dataset.id;
                    const existsInNewData = newJsonData.some(item => item.id == markerId);
                    if (!existsInNewData) {
                        marker.remove();
                        return false;
                    }
                    return true;
                });

                // Reset coordinates data
                coordinatesData = newJsonData.map(entry => ({
                    id: entry.id,
                    latitude: entry.lat,
                    longitude: entry.lon
                }));

                coordinatesData_cWpt = newcWptData.map(entry => ({
                    id: entry.id,
                    latitude: entry.lat,
                    longitude: entry.lon
                }));


                // Update the GeoJSON data for the line
                updateRoute();

            })
            .catch(error => console.error('Error:', error));
    }

    // Initialize the map and add the route
    map.on('load', () => {

        // Add the second route source and layer
        map.addSource('route2', {
            type: 'geojson',
            data: {
                type: 'FeatureCollection',
                features: []
            }
        });

        map.addLayer({
            id: 'routeLayer2',
            type: 'line',
            source: 'route2',
            layout: {
                'line-join': 'round',
                'line-cap': 'round'
            },
            paint: {
                'line-color': '#ff9900', // Orange color for the second route
                'line-width': 3
            }
        });
        // Add the first route source and layer
        map.addSource('route1', {
            type: 'geojson',
            data: {
                type: 'FeatureCollection',
                features: []
            }
        });

        map.addLayer({
            id: 'routeLayer1',
            type: 'line',
            source: 'route1',
            layout: {
                'line-join': 'round',
                'line-cap': 'round'
            },
            paint: {
                'line-color': '#F7455D', // Red color for the first route
                'line-width': 3
            }
        });
        // Initialize markers with the existing data
        jsonData.forEach((item, index) => {
            let color = item.id === 1 ? "#e50112" : "#808080";
            if (index === jsonData.length - 1) {
                color = "#00FF00";
            }
            createMarker({ id: item.id, lon: item.lon, lat: item.lat }, color);
        });


    });

    // Function to start the update interval
    function startUpdateInterval() {
        if (intervalId_map === null) {
            intervalId_map = setInterval(updateMarkers, updateInterval);
        }
    }

    // Function to stop the update interval
    function stopUpdateInterval() {
        if (intervalId_map !== null) {
            clearInterval(intervalId_map);
        }
    }

    // Set up the interval to call updateMarkers when the page is loaded
    document.addEventListener('turbo:load', () => {
        startUpdateInterval();
    });

    // // Stop the interval when navigating away from the page
    document.addEventListener('turbo:before-render', () => {
        stopUpdateInterval();
    });


</script>